# 非线性Dirac方程求解器

## 项目概述

本项目实现了求解一维非线性Dirac方程的三种方法：

1. **变分量子算法（VQA）**：混合伪谱-变分量子算法
2. **经典伪谱分裂步法**：标准的经典数值方法
3. **归一化经典分裂步法**：每步后手动归一化的经典方法

## 理论背景

### Dirac方程形式

一维非线性Dirac方程（双分量形式）：

```
i ∂Ψ/∂t = [-i α ∂/∂x + β] Ψ + λ₁(Ψ†βΨ)βΨ + λ₂‖Ψ‖²Ψ
```

其中：
- Ψ = (Ψ₀, Ψ₁)ᵀ 是双分量旋量
- α = σₓ = [[0,1],[1,0]]（Pauli-X矩阵）
- β = σz = [[1,0],[0,-1]]（Pauli-Z矩阵）
- λ₁：β-型非线性系数
- λ₂：标量非线性系数

### 分裂步方法

**线性子步**（公式4）：
```
Ψ̃ = exp(-iβΔt) F⁻¹[exp(-iαkΔt) F[Ψ]]
```

**非线性子步**（公式5-6）：
```
Ψ(t+Δt) = Ψ̃ + iΔt[λ₁(Ψ̃†βΨ̃)βΨ̃ + λ₂‖Ψ̃‖²Ψ̃]
```

### 量子编码方案

使用 **n+1** 个量子比特：
- 第1个比特：自旋比特（|0⟩对应Ψ₀，|1⟩对应Ψ₁）
- 后n个比特：位置比特（编码2ⁿ个空间点）

总希尔伯特空间维数：2^(n+1)

### VQA成本函数（公式30）

```
C(λ) = -2E_ov + (Δt·N/Δx)[(λ₂+λ₁)E_self + (λ₂-λ₁)E_cross]
```

其中：
- **E_ov**：重叠项 = Re⟨ψ(t+Δt)|ψ̃(t)⟩
- **E_self**：自项 = Im[∑_{σ,j} b*_{σ,j} |a_{σ,j}|² a_{σ,j}]
- **E_cross**：交叉项 = Im[∑_{σ,j} b*_{σ,j} |a_{1-σ,j}|² a_{σ,j}]

## 文件说明

### 主程序文件

1. **dirac_vqa_solver.py**
   - 变分量子算法实现
   - 使用Qiskit构建参数化量子电路
   - 通过L-BFGS-B优化器最小化成本函数

2. **dirac_classical_solver.py**
   - 经典伪谱分裂步法
   - 使用NumPy的FFT进行傅里叶变换
   - 直接时间步进，无归一化

3. **dirac_normalized_classical_solver.py**
   - 归一化版本的经典方法
   - 每个时间步后手动归一化波函数
   - 保持 ∫(|Ψ₀|² + |Ψ₁|²)dx = N_constant

4. **dirac_comparison_tool.py**
   - 对比分析工具
   - 计算RMSE、L2误差
   - 检查守恒量（归一化、自旋极化）
   - 生成对比图表

## 使用方法

### 1. 运行VQA求解器

```bash
python dirac_vqa_solver.py
```

**输出**：
- `/home/claude/dirac_vqa_results.png`：可视化结果（4个子图）
- `/home/claude/dirac_vqa_data.npz`：数值数据

**参数设置**（在文件中修改）：
```python
n = 5           # 位置量子比特数（2^5 = 32个空间点）
d = 10          # 电路深度
lambda1 = 1.0   # β非线性系数
lambda2 = 0.5   # 标量非线性系数
time_steps = 50 # 时间步数
dt = 0.01       # 时间步长
```

### 2. 运行经典求解器

```bash
python dirac_classical_solver.py
```

**输出**：
- `/home/claude/dirac_classical_results.png`
- `/home/claude/dirac_classical_data.npz`

### 3. 运行归一化经典求解器

```bash
python dirac_normalized_classical_solver.py
```

**输出**：
- `/home/claude/dirac_normalized_classical_results.png`
- `/home/claude/dirac_normalized_classical_data.npz`

### 4. 比较三种方法

```bash
python dirac_comparison_tool.py
```

**输出**：
- `/home/claude/dirac_comparison_results.png`：对比图表
- 终端输出统计信息（RMSE、归一化误差等）

## 可视化结果说明

### 单个求解器的输出（4个子图）

1. **左上**：上自旋分量 |Ψ₀|² 随时间演化
2. **右上**：下自旋分量 |Ψ₁|² 随时间演化
3. **左下**：总概率密度 |Ψ₀|² + |Ψ₁|²
4. **右下**：自旋极化 |Ψ₀|² - |Ψ₁|²

### 对比工具的输出（6个子图）

**第一行**：
1. RMSE随时间变化
2. 归一化误差随时间变化
3. 自旋极化总量随时间变化

**第二行**：
4. 最终时刻上自旋分量对比
5. 最终时刻下自旋分量对比
6. 最终时刻总概率密度对比

## 误差度量

### RMSE（公式31）

```
RMSE = sqrt( 1/(2ⁿ) ∑_{σ,j} (|Ψ^num_{σ,j}| - |Ψ^ref_{σ,j}|)² )
```

### L2误差（公式32）

```
L2_error = sqrt( 1/(2ⁿ) ∑_j ‖Ψ^num_j - Ψ^ref_j‖² )
```

### 守恒量检查

1. **归一化守恒**：∫(|Ψ₀|² + |Ψ₁|²)dx 应保持常数
2. **自旋极化演化**：∫(|Ψ₀|² - |Ψ₁|²)dx 的变化

## 算法特点对比

### VQA方法
- ✅ 利用量子态的内在归一化
- ✅ 可能具有量子优势（对高维问题）
- ❌ 需要经典优化（可能陷入局部最优）
- ❌ 计算时间较长

### 经典方法
- ✅ 计算速度快
- ✅ 确定性算法
- ❌ 归一化可能随时间漂移
- ✅ 实现简单

### 归一化经典方法
- ✅ 严格保持归一化
- ✅ 适合作为参考解
- ❌ 额外的归一化步骤
- ✅ 实现简单

## 依赖库

```bash
pip install numpy matplotlib qiskit scipy
```

版本要求：
- numpy >= 1.20.0
- matplotlib >= 3.3.0
- qiskit >= 0.45.0

## 参数调优建议

### VQA参数
- **n**：从5开始，增加会提高精度但计算成本指数增长
- **d**：建议10-15，过深可能导致barren plateau
- **dt**：需满足稳定性条件，建议0.001-0.01
- **time_steps**：VQA通常适用于50-100步
- **initial_runs**：第一步建议5-10次重复
- **ftol**：收敛容差，建议1e-12到1e-14

### 经典方法参数
- **dt**：可以比VQA稍大，建议0.01-0.1
- **num_steps**：可以运行更多步（数百到数千步）

## 四种测试案例（对应文档）

文档中提到了4种测试案例（case 1-4）：

```python
# Case 1: 线性Dirac方程
lambda1 = 0.0
lambda2 = 0.0

# Case 2: 仅标量非线性
lambda1 = 0.0
lambda2 = 1.0

# Case 3: 仅β非线性
lambda1 = 1.0
lambda2 = 0.0

# Case 4: 完整非线性
lambda1 = 1.0
lambda2 = 1.0
```

可以修改求解器中的参数来运行不同案例。

## 常见问题

### Q1: VQA优化不收敛怎么办？
- 增加`initial_runs`
- 调整`dt`（变小）
- 减少`time_steps`
- 调整电路深度`d`

### Q2: 经典方法出现数值不稳定？
- 减小`dt`
- 使用归一化版本

### Q3: 内存不足？
- 减少`n`（空间分辨率）
- 减少保存的时间步数

### Q4: 计算太慢？
- VQA：减少`maxiter`、`time_steps`
- 使用经典方法作为快速测试

## 扩展方向

1. **二维Dirac方程**：需要更多量子比特（n_x + n_y + 1）
2. **外部势场**：在线性步中添加V(x)项
3. **不同初始条件**：孤子、波包碰撞等
4. **自适应时间步长**：根据局部误差调整dt
5. **真实量子硬件**：在NISQ设备上运行VQA

## 引用

如果使用本代码，请引用原始论文中的方法（对应上传的PDF文档）。

## 作者与联系

本代码基于文档"Dirac_中文版.pdf"中描述的算法实现。

---

**Happy Computing! 🎉**
